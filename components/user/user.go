package user

import (
	"bytes"
	"encoding/json"
	"fmt"
	"html/template"
	"log"
	"math/rand"
	"net/http"
	"net/smtp"
	"time"

	"GOLANG_SERVER/components/db"
	"GOLANG_SERVER/components/schema"

	"golang.org/x/crypto/bcrypt"
)

// GenerateOTP generates a random 6-digit OTP
func GenerateOTP() string {
	rand.Seed(time.Now().UnixNano())
	otp := rand.Intn(10000)
	return fmt.Sprintf("%04d", otp)
}

// SendOTPEmail sends an OTP to the user's email
func SendOTPEmail(email, otp string) error {
	log.Println("Sending OTP to email...")

	from := "toonglar@gmail.com"      // Replace with your email address
	password := "gbgs bzkr kdbg xvqe" // Replace with your app-specific password
	smtpHost := "smtp.gmail.com"
	smtpPort := "587"

	// Set up authentication information.
	auth := smtp.PlainAuth("", from, password, smtpHost)

	log.Println("Sending email to:", email)

	// Dynamic content for the email
	emailData := struct {
		Name    string
		Message string
		OTP     string
	}{
		Name:    "John Doe",
		Message: "This is a dynamic message generated by Go!",
		OTP:     otp,
	}

	// Create dynamic HTML email content
	emailTemplate := `
	<html>
		<head></head>
		<body>
			<h1>Hello, {{.Name}}!</h1>
			<p>{{.Message}}</p>
			<p>Your OTP is: <strong>{{.OTP}}</strong></p>
		</body>
	</html>
	`

	// Parse the template and generate HTML
	tmpl, err := template.New("email").Parse(emailTemplate)
	if err != nil {
		log.Println("Error parsing email template:", err)
		return err
	}

	var body bytes.Buffer
	if err := tmpl.Execute(&body, emailData); err != nil {
		log.Println("Error executing email template:", err)
		return err
	}

	// Set up email subject and content
	to := []string{email}
	msg := []byte("Subject: OTP Verification\r\n" +
		"MIME-version: 1.0;\r\n" +
		"Content-Type: text/html; charset=\"UTF-8\";\r\n\r\n" +
		body.String())

	// Send the email
	err = smtp.SendMail(smtpHost+":"+smtpPort, auth, from, to, msg)
	if err != nil {
		log.Println("Error sending email:", err)
		return err
	} else {
		log.Println("Sent OTP to email successfully.")
		return nil
	}
}

// SendOTP sends an OTP to the user's email and returns the OTP
func SendOTP(w http.ResponseWriter, r *http.Request) {

	if r.Method != http.MethodPost { // Allow only POST requests
		http.Error(w, "Invalid request method", http.StatusMethodNotAllowed)
		return
	}

	w.Header().Set("Content-Type", "application/json")

	// Parse the request body to get user details
	var userDetails map[string]string
	if err := json.NewDecoder(r.Body).Decode(&userDetails); err != nil {
		http.Error(w, err.Error(), http.StatusBadRequest)
		return
	}

	// Handle both lowercase and uppercase keys
	email := userDetails["email"]
	if email == "" {
		email = userDetails["Email"]
	}

	// Generate OTP
	otp := GenerateOTP()

	// Send OTP to user's email
	if err := SendOTPEmail(email, otp); err != nil {
		http.Error(w, err.Error(), http.StatusInternalServerError)
		return
	}

	// Send a response
	response := map[string]string{"message": "OTP sent successfully. Please check your email for the OTP.", "OTP": otp}
	w.WriteHeader(http.StatusOK)
	if err := json.NewEncoder(w).Encode(response); err != nil {
		http.Error(w, err.Error(), http.StatusInternalServerError)
		return
	}
}

// Register handles user registration
func Register(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodPost { // Allow only POST requests
		http.Error(w, "Invalid request method", http.StatusMethodNotAllowed)
		return
	}

	w.Header().Set("Content-Type", "application/json")

	// Parse the request body to get user details
	var userDetails map[string]string
	if err := json.NewDecoder(r.Body).Decode(&userDetails); err != nil {
		http.Error(w, err.Error(), http.StatusBadRequest)
		return
	}

	// Handle both lowercase and uppercase keys
	email := userDetails["email"]
	if email == "" {
		email = userDetails["Email"]
	}
	password := userDetails["password"]
	if password == "" {
		password = userDetails["Password"]
	}

	// Hash the password
	hashedPassword, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)
	if err != nil {
		http.Error(w, err.Error(), http.StatusInternalServerError)
		return
	}

	// Convert the user details to a User struct
	user := schema.User{
		Email:    email,
		Password: string(hashedPassword),
	}

	// Save user details to database
	if _, err := db.StoreUser(user); err != nil {
		http.Error(w, err.Error(), http.StatusInternalServerError)
		return
	} else {
		log.Println("User registered successfully.")
	}

	// Send a response
	response := map[string]string{"message": "User registered successfully. Please check your email for the OTP."}
	log.Println("User registered successfully.")
	w.WriteHeader(http.StatusOK)
	if err := json.NewEncoder(w).Encode(response); err != nil {
		http.Error(w, err.Error(), http.StatusInternalServerError)
		return
	}
}

// Login handles user login
func Login(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodPost { // Allow only POST requests
		http.Error(w, "Invalid request method", http.StatusMethodNotAllowed)
		return
	}

	w.Header().Set("Content-Type", "application/json")

	// Parse the request body to get user details
	var userDetails map[string]string
	if err := json.NewDecoder(r.Body).Decode(&userDetails); err != nil {
		http.Error(w, err.Error(), http.StatusBadRequest)
		return
	}

	// Handle both lowercase and uppercase keys
	email := userDetails["email"]
	if email == "" {
		email = userDetails["Email"]
	}
	password := userDetails["password"]
	if password == "" {
		password = userDetails["Password"]
	}

	// Check if user exists
	user, err := db.Login(email, password)
	if err != nil {
		http.Error(w, "Invalid email or password", http.StatusUnauthorized)
		return
	}

	// Compare the provided password with the stored hashed password
	err = bcrypt.CompareHashAndPassword([]byte(user.Password), []byte(password))
	if err != nil {
		http.Error(w, "Invalid email or password", http.StatusUnauthorized)
		return
	}

	// Send a response
	response := map[string]string{"message": "Login successful"}
	log.Println("User logged in successfully.")
	w.WriteHeader(http.StatusOK)
	if err := json.NewEncoder(w).Encode(response); err != nil {
		http.Error(w, err.Error(), http.StatusInternalServerError)
		return
	}
}
